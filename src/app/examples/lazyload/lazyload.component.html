<!-- <p>
     <br> 懒加载：loadChildren 这里使用到了懒加载LoadChildren属性。
    <br> 这里没有将对应的模块导入到AppModule中，而是通过loadChildren属性，告诉Angular路由依据loadChildren属性配置的路径去加载对应的模块。
    <br> 
    <br> loadChildren的属性值由三部分组成：
    <br> 需要导入模块的相对路径
    <br> #分隔符
    <br> 导出模块类的名称
    <br>Example // 惰性加载的语法：[loadChildren] 后面紧跟着一个字符串，它指向模块的相对路径，然后是一个 #，然后是该模块的类名
    <br>{ path: 'lazyload', loadChildren: './examples/lazyload/lazyload.module#LazyloadModule'},
</p> -->
<p>lazyload works!<br/>{{time}}</p>
<p>懒加载：loadChildren 这里使用到了懒加载LoadChildren属性。</p>
<p>这里没有将对应的模块导入到AppModule中，而是通过loadChildren属性，告诉Angular路由依据loadChildren属性配置的路径去加载对应的模块。</p>
<p>这就是模块懒加载功能的具体应用，当用户访问 /xxx/** 路径的时候，才会加载对应的模块，这样处理好的处是能够够节省资源开销，只有在用户需要的时候通过点击路由之后再加载对应的模块, 这减少了应用启动时加载资源的大小。</p>
<p>loadChildren的属性值由三部分组成：</p>
<p>需要导入模块的相对路径</p>
<p>#分隔符</p>
<p>导出模块类的名称</p>
<p>Example // 惰性加载的语法：[loadChildren] 后面紧跟着一个字符串，它指向模块的相对路径，然后是一个 #，然后是该模块的类名</p>
<p> path: 'lazyload', loadChildren: './examples/lazyload/lazyload.module#LazyloadModule'</p>
<p></p>
<p></p>
<br><br>
<p>preload works!<br/>
<p>preload的具体实现集成在了preload.route.ts</p>
<p>把CustomPreloadingStrategy引入到app.routing.ts里，</p>
<img src="../../../assets/images/preload.PNG" alt="">
    <br>
<p>对于需要预加载的模块在路由下面设置preload=true</p>
<img src="../../../assets/images/preload-true.PNG" alt="">
    <br>
<br><br><br><br>